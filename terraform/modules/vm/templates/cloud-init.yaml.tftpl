#cloud-config
package_update: true
packages:
  - docker.io
  - docker-compose-v2
  - curl
  - ca-certificates

write_files:
  - path: ${app_dir}/${project_name}/docker-compose.yml
    permissions: "0644"
    content: |
      services:
        nginx-proxy:
          image: docker.io/nginxproxy/nginx-proxy:${nginx_proxy_tag}
          container_name: nginx-proxy
          restart: unless-stopped
          ports:
            - "80:80"
            - "443:443"
          volumes:
            - /srv/${cert_device_name}/nginx/conf:/etc/nginx/conf.d
            - /srv/${cert_device_name}/nginx/vhost:/etc/nginx/vhost.d
            - /srv/${cert_device_name}/nginx/html:/usr/share/nginx/html
            - /srv/${cert_device_name}/nginx/dhparam:/etc/nginx/dhparam
            - /srv/${cert_device_name}/nginx/certs:/etc/nginx/certs:ro
            # WARNING: sharing docker.sock has security implications
            - /var/run/docker.sock:/tmp/docker.sock:ro

        acme-companion:
          image: docker.io/nginxproxy/acme-companion:${acme_companion_tag}
          container_name: nginx-proxy-acme
          restart: unless-stopped
          depends_on:
            - nginx-proxy
          environment:
            - NGINX_PROXY_CONTAINER=nginx-proxy
            - DEFAULT_EMAIL=sivanajani@swissntech.ch
            # Uncomment the following line for testing purposes
            # - ACME_CA_URI=https://acme-staging-v02.api.letsencrypt.org/directory
          volumes:
            - /srv/${cert_device_name}/nginx/certs:/etc/nginx/certs:rw
            - /srv/${cert_device_name}/nginx/acme:/etc/acme.sh
            - /srv/${cert_device_name}/nginx/vhost:/etc/nginx/vhost.d
            - /srv/${cert_device_name}/nginx/html:/usr/share/nginx/html
            - /var/run/docker.sock:/var/run/docker.sock:ro

        backend:
          image: europe-west6-docker.pkg.dev/${project_id}/${project_name}/${project_name}-backend:${image_tag}
          environment:
            PYTHONUNBUFFERED: "1"
            HOST: "0.0.0.0"
            PORT: "8080"
          expose:
            - "8080"
          restart: unless-stopped

        frontend:
          image: europe-west6-docker.pkg.dev/${project_id}/${project_name}/${project_name}-frontend:${image_tag}
          expose:
            - "80"
          environment:
            - VIRTUAL_HOST=shaperag.com,www.shaperag.com
            - VIRTUAL_PORT=80
            - LETSENCRYPT_HOST=shaperag.com,www.shaperag.com
            - LETSENCRYPT_EMAIL=sivanajani@swissntech.ch
          restart: unless-stopped

      volumes:
        conf:
        vhost:
        html:
        dhparam:
        certs:
        acme:

  - path: /usr/local/bin/artifact-registry-login
    permissions: "0755"
    content: |
      #!/bin/sh
      set -eu

      # Use the same path as the systemd unit
      CONFIG_PATH="/run/pdfrag-docker"
      REGISTRY="https://europe-west6-docker.pkg.dev"

      mkdir -p "$CONFIG_PATH"

      TOKEN="$(curl -s -H "Metadata-Flavor: Google" \
        http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token \
        | sed -n 's/.*"access_token":"\([^"]*\)".*/\1/p')"

      [ -n "$TOKEN" ] || { echo "No access token from metadata server"; exit 1; }

      # Write creds explicitly to CONFIG_PATH (no env var needed)
      printf '%s' "$TOKEN" | docker --config "$CONFIG_PATH" login \
        -u oauth2accesstoken --password-stdin "$REGISTRY"

  - path: /etc/systemd/system/web.service
    permissions: "0644"
    content: |
      [Unit]
      Description=Web via Docker Compose
      After=docker.service network-online.target
      Wants=network-online.target
      Requires=docker.service

      [Service]
      Type=oneshot
      RemainAfterExit=yes
      WorkingDirectory=${app_dir}/${project_name}
      Environment=DOCKER_CONFIG=/run/pdfrag-docker
      ExecStartPre=/usr/local/bin/artifact-registry-login
      ExecStartPre=/usr/bin/docker compose pull
      ExecStart=/usr/bin/docker compose up -d
      ExecStop=/usr/bin/docker compose down
      TimeoutStartSec=0

      [Install]
      WantedBy=multi-user.target

disk_setup:
  /dev/disk/by-id/google-${cert_device_name}:
    table_type: gpt
    layout: true
    overwrite: false

fs_setup:
  - label: dockerdata
    filesystem: ext4
    device: /dev/disk/by-id/google-${cert_device_name}
    overwrite: false

mounts:
  - [ /dev/disk/by-id/google-${cert_device_name}, /srv/${cert_device_name}, auto, "defaults,nofail", "0", "2" ]

runcmd:
  - mkdir -p /srv/${cert_device_name}
  - chown -R root:root /srv/${cert_device_name}
  - systemctl enable --now docker
  - systemctl daemon-reload
  - systemctl enable --now web.service

final_message: |
  Cloud init finished. The application should be running shortly.